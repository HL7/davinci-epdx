
@startuml
autonumber
== Connection Intitialization ==
group #LightBlue Step 1: Verify Exchange, establish mutual TLS, and verify trust.
	Payer2 -> PayerDirectory : Query
	PayerDirectory -> Payer2 : Return endpoint, mutual TLS public cert,
	Payer2 -> Payer2 : Verify Cert
	Payer2 -> Payer1 : Server-Server OAuth -- Establish Mutual TLS
	Payer1 -> PayerDirectory : Query mutual TLS Public Cert
	PayerDirectory ->> Payer1 : Return mTLS public cert
	Payer1 -> Payer1 : Verify Cert
end
group Step 1a: OAuth 2.0 Dynamic Registration via mTLS connection
	Payer2 -> Payer1 : Request registration (JWT with registration details)
  Payer1 -> Payer2 : Return Client Credentials (ClientID/ClientSecret)
end
== Member Connection ==
group Step 2: Establish common member
	Payer2 -> Payer1 : Send bundle (Patient, Coverage & Consent) to $member-match operation
	Payer1 -> Payer1 : Verify member
  Payer1 -> Payer1 : Store or Compute Consent (all / non-sensitive) for Member
  note right
  	Member: ID
    Policy: all | non-sensitive
    Consent Period: start, end
  endnote
	Payer1 -> Payer2 : Return Member ID
  note right
  	Payer1 may determine concurrent coverage is in effect
    and covered by member consent to trigger reciprocal
    app registration and $MemberAccess request
  endnote
end
== Data Requests ==
group Step 3: Request Access and refresh token
	Payer2 -> Payer1 : Use OAuth2.0 token endpoint to request access using member ID
  note right
  	$MemberAccess operation
  endnote
  Payer1 -> Payer2 : Return access and refresh token
end
group #LightBlue Step 4: Exchange PDEX (USCDI) Information via API
	Payer2 -> Payer1 : Get access token using refresh token, if necessary
  Payer2 -> Payer1 : Use access token to access API
	Payer1 -> Payer2 : Return $everything or incremental data as appropriate
  note right
  	Use retrieval method, as defined in use case scenarios, such as:
      1.) Individual search against each USCDI resource
      2.) $everything operation
      3.) asynchronous Bulk FHIR methods.
  endnote
end
@enduml
